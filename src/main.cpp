#include <sexp.h>

#include <iostream>
#include <fstream>
#include <cassert>
#include <thread>
#include <chrono>


// serial/linux.c
#include <iostream>
#include <fcntl.h>
#include <termios.h>
#include <unistd.h>
#include <errno.h>
#include <cstring>

#define LOGN(str) std::cerr << str << std::endl
#define LOG(str) std::cerr << str;

class SerialPort {
public:
  SerialPort(){};
  SerialPort(const char* name, unsigned int baudrate, bool hwfc){};
  virtual ~SerialPort() {}

  virtual auto send(const std::string_view view) -> int = 0;
  virtual auto recv(std::string& dest) -> int = 0;
  virtual auto getc(char& c) -> int = 0;
  virtual auto wait_for_data() -> bool = 0;

  auto null_route(int time_ms) -> void {
    auto end = current_time() + (time_ms * 1000);
    while (current_time() < end) {
      char c;
      wait_for_data();
      getc(c);
    }
  }

private:
  auto current_time() -> int64_t {
    // Generated by Phind
    auto now = std::chrono::high_resolution_clock::now();
    auto duration = now.time_since_epoch();
    auto micros = std::chrono::duration_cast<std::chrono::microseconds>(duration);
    return micros.count();
  }
};

class LinuxSerialPort : public SerialPort {
private:
    int fd;

  public:
    LinuxSerialPort(const char* device_path, unsigned int baud_rate, bool hw_flow_control)
      // First version generated by phind
      : fd(-1) {
      fd = open(device_path, O_RDWR | O_NOCTTY | O_NONBLOCK);
      if (fd < 0) {
        throw std::runtime_error("Failed to open serial port");
      }

      struct termios tty;
      memset(&tty, 0, sizeof tty);

      if (tcgetattr(fd, &tty) != 0) {
        throw std::runtime_error("Failed to get terminal attributes");
      }

      cfsetispeed(&tty, baud_rate);
      cfsetospeed(&tty, baud_rate);

      tty.c_cflag &= ~PARENB;
      tty.c_cflag &= ~CSTOPB;
      tty.c_cflag &= ~CSIZE;
      tty.c_cflag |= CS8;
      tty.c_cflag &= ~CRTSCTS;
      tty.c_cflag |= (hw_flow_control ? CRTSCTS : 0);

      tty.c_iflag &= ~(IXON | IXOFF | IXANY);
      tty.c_iflag &= ~(ICRNL | INLCR);
      tty.c_oflag &= ~OPOST;
      tty.c_oflag &= ~ONLCR;
      tty.c_lflag &= ~(ICANON | ECHO | ECHONL | ISIG);

      if (tcsetattr(fd, TCSANOW, &tty) != 0) {
        throw std::runtime_error("Failed to set terminal attributes");
      }
    }

    ~LinuxSerialPort() { close(fd); }

    auto send(const std::string_view view) -> int {
      this->send_c_str(view.data(), view.length());

      return 0;
    }

    auto getc(char& c) -> int {
      if (!this->wait_for_data()) {
        // The wait timed-out, we won't read anything
        return 0;
      }

      ssize_t bytes_read = read(fd, &c, 1);
      if (bytes_read < 0) {
        throw std::runtime_error("Error reading from serial port");
      }
      // LOGN("got[" << c << "]");

      return bytes_read;
    }

    auto recv(std::string& dest) -> int {
      // TODO: implement
      return 0;
    }

  private:
    char rxbuf[256];

    void send_c_str(const char* data, size_t len) {
      ssize_t bytes_written = write(fd, data, len);
      if (bytes_written < 0) {
        throw std::runtime_error("Error writing to serial port");
      }
    }

    auto wait_for_data() -> bool {
      fd_set read_fdset;
      FD_ZERO(&read_fdset);
      FD_SET(fd, &read_fdset);

      struct timeval tv;
      tv.tv_sec = 0;
      tv.tv_usec = 100000;  // 100ms timeout

      // LOGN("wait for data");
      select(fd + 1, &read_fdset, NULL, NULL, &tv);

      if (!FD_ISSET(fd, &read_fdset)) {
        return false;
      }

      return true;
    }

    int receive_c_str(char* buffer, size_t max_size) {
      this->wait_for_data();

      // LOGN("read");
      ssize_t bytes_read = read(fd, buffer, max_size - 1);
      if (bytes_read < 0) {
        throw std::runtime_error("Error reading from serial port");
      }
      buffer[bytes_read] = '\0';
      return static_cast<int>(bytes_read);
    }
};

auto serial_read_line(SerialPort& serial, std::string& line) -> bool {
  // TODO: input error handling, using some C++ smarts
  while (true) {
    char c;
    int len = serial.getc(c);

    if (len == 0) {
      // better luck next time
      continue;
    }

    if (c == '\n') {
      break;
    }

    LOGN("got [" << c << "]");
    line += c;

    if (c == '>') {
      break;
    }
  }

  // LOGN("line: " << line);

  return true;
}

// ~serial/linux.c

auto no_trail_whitespace(std::string& str) -> std::string_view {
  std::string_view view = str;

  while (std::isspace(view.back())) {
    view.remove_suffix(1);
  }

  return view;
}

auto is_prompt(std::string line) -> bool {
  return (no_trail_whitespace(line).back() == '>');
}

auto stream_read_line(std::istream& is, std::string& line) -> bool {
  // Poll for input
  // TODO: add a timeout or sprinkle some async
  // and use `return false`
  is >> std::noskipws;  // Don't skip whitespace

  while (!getline(is, line)) {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
  }

  return true;
}

template<typename F>
auto read_result(F read_line) -> std::string {
  // Read the result of the computation, until the lisp prompt
  // We can optionally track the memory consumption from the prompt
  char c;
  std::string result;
  std::string line;

  while (read_line(line) && !is_prompt(line)) {
    // do we need to give up after some time? e.g. if s-exp is bad, the prompt
    // will never be shown.

    result += line + '\n';
  }

  // std::cerr << std::endl;

  return result;
}

auto disable_ulisp_echo(SerialPort& serial) -> void {
  // Works with a special build of ulisp, where auto re-enabling of echo is
  // compiled out.

  const std::string noecho {";noecho;"};
  serial.send(noecho);

  // flush serial buffer
  serial.null_route(100);
}

auto main(int argc, char* argv[]) -> int {
  assert(argc == 2);

  std::string uart_path = argv[1];
  std::cerr << "Path: " << uart_path << std::endl;
  std::cerr.flush();

  // TODO: use argv[1] to select serial port type
  // TODO: pass serial params via cli too
  LinuxSerialPort serial_port(uart_path.c_str(), 115200, false);

  disable_ulisp_echo(serial_port);

  Sexp exp;
  std::cin >> exp;

  std::cerr << "Eval: " << exp << std::endl;
  // send s-exp to target
  serial_port.send(exp.get());

  // read and log result

  std::string result = read_result(
      [&serial_port](std::string& line) -> bool { return serial_read_line(serial_port, line); });

  std::cerr << "Result: {" << result << "}";

  return 0;
}
