#include <sexp.h>

#include <iostream>
#include <fstream>
#include <cassert>
#include <thread>
#include <chrono>


// serial/linux.c
#include <iostream>
#include <fcntl.h>
#include <termios.h>
#include <unistd.h>
#include <errno.h>
#include <cstring>

#define LOGN(str) std::cerr << str << std::endl
#define LOG(str) std::cerr << str;

class SerialPort {
private:
    int fd;

  public:
    SerialPort(const char* device_path, int baud_rate, bool hw_flow_control)
      // First version generated by phind
      : fd(-1) {
      // fd = open(device_path, O_RDWR | O_NOCTTY);
      fd = open(device_path, O_RDWR | O_NOCTTY | O_NONBLOCK);
      if (fd < 0) {
        throw std::runtime_error("Failed to open serial port");
      }

      struct termios tty;
      memset(&tty, 0, sizeof tty);

      if (tcgetattr(fd, &tty) != 0) {
        throw std::runtime_error("Failed to get terminal attributes");
      }

      cfsetispeed(&tty, baud_rate);
      cfsetospeed(&tty, baud_rate);

      tty.c_cflag &= ~PARENB;
      tty.c_cflag &= ~CSTOPB;
      tty.c_cflag &= ~CSIZE;
      tty.c_cflag |= CS8;
      tty.c_cflag &= ~CRTSCTS;
      tty.c_cflag |= (hw_flow_control ? CRTSCTS : 0);

      tty.c_iflag &= ~(IXON | IXOFF | IXANY);
      tty.c_iflag &= ~(ICRNL | INLCR);
      tty.c_oflag &= ~OPOST;
      tty.c_oflag &= ~ONLCR;
      tty.c_lflag &= ~(ICANON | ECHO | ECHONL | ISIG);

      if (tcsetattr(fd, TCSANOW, &tty) != 0) {
        throw std::runtime_error("Failed to set terminal attributes");
      }
    }

    ~SerialPort() { close(fd); }

    auto send(const std::string_view view) -> int {
      this->send_c_str(view.data(), view.length());

      return 0;
    }

    // auto receive(std::string& buf, int max) -> int {
    //   // TODO: fix that later
    //   assert(max <= sizeof(this.rxbuf));

    //   auto len = this.receive_c_str(this.rxbuf, max);
    //   assert(len > 0);

    //   buf.append(this.rxbuf, len);
    //   return len;
    // }
    auto getc() -> char {
      char c;

      while (!this->wait_for_data())
        ;

      ssize_t bytes_read = read(fd, &c, 1);
      if (bytes_read < 0) {
        throw std::runtime_error("Error reading from serial port");
      }
      // LOGN("got[" << c << "]");

      return c;
    }

    auto current_time() -> int64_t {
      // Generated by Phind
      auto now = std::chrono::high_resolution_clock::now();
      auto duration = now.time_since_epoch();
      auto micros = std::chrono::duration_cast<std::chrono::microseconds>(duration);
      return micros.count();
    }

    auto null_route(int time_ms) -> void {
      // Discard data for a given duration

      auto end = current_time() + (time_ms * 1000);
      while (current_time() < end) {
        char c;
        this->wait_for_data();
        ssize_t bytes_read = read(fd, &c, 1);
      }
    }

  private:
    char rxbuf[256];

    void send_c_str(const char* data, size_t len) {
      ssize_t bytes_written = write(fd, data, len);
      if (bytes_written < 0) {
        throw std::runtime_error("Error writing to serial port");
      }
    }

    auto wait_for_data() -> bool {
      fd_set read_fdset;
      FD_ZERO(&read_fdset);
      FD_SET(fd, &read_fdset);

      struct timeval tv;
      tv.tv_sec = 0;
      tv.tv_usec = 100000;  // 100ms timeout

      // LOGN("wait for data");
      select(fd + 1, &read_fdset, NULL, NULL, &tv);

      if (!FD_ISSET(fd, &read_fdset)) {
        return false;
      }

      return true;
    }

    int receive_c_str(char* buffer, size_t max_size) {
      this->wait_for_data();

      // LOGN("read");
      ssize_t bytes_read = read(fd, buffer, max_size - 1);
      if (bytes_read < 0) {
        throw std::runtime_error("Error reading from serial port");
      }
      buffer[bytes_read] = '\0';
      return static_cast<int>(bytes_read);
    }
};

auto serial_read_line(SerialPort& serial, std::string& line) -> bool {
  // TODO: input error handling, using some C++ smarts
  while (char c = serial.getc()) {
    if (c == '\n') {
      break;
    }

    LOGN("got [" << c << "]");
    line += c;

    if (c == '>') {
      break;
    }
  }

  // LOGN("line: " << line);

  return true;
}

// ~serial/linux.c

auto no_trail_whitespace(std::string& str) -> std::string_view {
  std::string_view view = str;

  while (std::isspace(view.back())) {
    view.remove_suffix(1);
  }

  return view;
}

auto is_prompt(std::string line) -> bool {
  return (no_trail_whitespace(line).back() == '>');
}

auto stream_read_line(std::istream& is, std::string& line) -> bool {
  // Poll for input
  // TODO: add a timeout or sprinkle some async
  // and use `return false`
  is >> std::noskipws;  // Don't skip whitespace

  while (!getline(is, line)) {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
  }

  return true;
}

template<typename F>
auto read_result(F read_line) -> std::string {
  // Read the result of the computation, until the lisp prompt
  // We can optionally track the memory consumption from the prompt
  char c;
  std::string result;
  std::string line;

  while (read_line(line) && !is_prompt(line)) {
    // do we need to give up after some time? e.g. if s-exp is bad, the prompt
    // will never be shown.
    // std::cerr << "[" << line << "]";

    result += line + '\n';
  }

  // std::cerr << std::endl;

  return result;
}

auto disable_ulisp_echo(SerialPort& serial) -> void {
  // Works with a special build of ulisp, where auto re-enabling of echo is
  // compiled out.

  const std::string noecho {";noecho;"};
  serial.send(noecho);

  // flush serial buffer
  serial.null_route(100);
}

auto main(int argc, char* argv[]) -> int {
  assert(argc == 2);

  std::string uart_path = argv[1];
  std::cerr << "Path: " << uart_path << std::endl;
  std::cerr.flush();

  // TODO: use argv[1] to select serial port type
  // TODO: pass serial params via cli too
  SerialPort serial_port(uart_path.c_str(), 115200, false);

  // // will be flushed/closed by RAII
  // std::fstream uartstream(uart_path);
  // assert(uartstream.is_open());

  disable_ulisp_echo(serial_port);

  Sexp exp;
  std::cin >> exp;

  std::cerr << "Eval: " << exp << std::endl;
  // "send" s-exp to target
  // for now, we echo it back to the terminal, to avoid needing a sink program
  // std::cout << exp << std::endl;
  serial_port.send(exp.get());

  // read and log result

  // std::string result = read_result(
  //     [&uartstream](std::string& line) -> bool { return stream_read_line(uartstream, line); });

  std::string result = read_result(
      [&serial_port](std::string& line) -> bool { return serial_read_line(serial_port, line); });

  std::cerr << "Result: {" << result << "}";

  return 0;
}
